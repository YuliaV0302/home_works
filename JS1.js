//'number' + 3 + 3 //спочатку відбувається конкатенація між рядком і числом за допомогою оператора +, потім за допомогою іншого + знову конкатенація.
//як результат number33

//null + 3 // null при перетворенні це 0, отже 0+3, результат 3

//5 && "qwerty" // спочатку перевіряється значення 5 (true), потім qwerty, аоно теж істинне.Оператор && повертає останнє істинне значення, отже результат qwerty

//+'40' + +'2' + "hillel"; // '40' це рядок, '2' також рядок. + перед ними - це унарний плюс,який перетворює рядки в числа. Отже,40 і 2. Иіж ними стоїть  знак додавання, 40+2=42.
// 42+ "hillel" відбувається конкатенація, отже результат 42hillel

//'10' - 5 === 6; // '10' це операнд, який є рядком.Система намагається перетворити його в число.Отже,10-5=5. Далі іде операція строгого порівняння 5===6,при якому порівнюються
//значення. Але 5 не дорівнює 6, отже результат FALSE

//true + false // булеві значення true та false.Система пертворює ці значення відповідно у 1 та 0. Результат: 1+0=1.

//'4px' - 3 // '4px' це рядкове значення,яке при приведення до числа дає NaN, оскільки містить не числові значення рх. Поскільки всі операції з NaN дають NaN, результат обчислення NaN

//'4' - 3 // '4' це рядок,яке JS намагається привести до числа. Отже, 4-3=1

//'6' + 3 ** 0; // ** оператор піднесення в степінь.Результат завжди 1. Отже, 3**0=1. Далі '6' це рядкове значення, і поскільки є оператор +, то відповідно відбувається конкатенація
// результат виразу '6'+1 = '61' рядкове значення

// 12 / '6' // при діленні рядкове значення '6' перетвориться в числове, і результатом буде 12/6=2

// '10' + (5 === 6); //спочатку дивимося на вираз в дужках, де відбувається операція строго порівняння. Значення нерівні 5 !=6, отже false. '10' це рядкове значення, і присутній
// оператор + , отже відбувається процес конкатенації , результатом буде '10false'

// null == '' // присутній оператор не строгого порівняння ==, але зі значенням null нічого не можна порівняти , вираз '' порожній рядок. І хоч це є істинне значення, але при
// порівнянні з null буде false

// 3 ** (9 / 3); // спочатку виконується операція в дужках,результат 9/3=3. Оператор ** це піднесення в степінь, отже 3**3 = 27

// !!'false' == !!'true' // оператор логічного заперечення !перетворює значення в протилежне, а два !! інвертують значення назад. У виразах якщо хоч одне значення true, результат
// завжди true

// 0 || '0' && 1 // спочатку оцінюємо вираз '0' && 1, де '0' істинне значення яке перетворюється в 1, 1 -  також істинне , результат 1. Далі 0 АБО 1, і поскільки 0 це false, а 1 це
// true , то якщо маємо хоч одне значення true при операторі || , завжди true . Отже результат 1


// (+null == false) < 1; // оператор + перетворює null в число, це 0. false при порівнянні з числом перетворюється в 0, тому вираз 0 == false дає true.
// далі порівнюємо true < 1, true при порівнянні з числом перетворюється на 1, отже 1<1 це буде false.

// false && true || true   // false && true дає результат false, оскільки оператор && повертає перший неправдивий результат. Далі операція АБО, при цьому якщо хоча б один оператор
// true, результат буде завжди  true.  Отже false  || true = true

// false && (false || true); // результат false

// (+null == false) < 1 ** 5; // Оператор == порівнює 0 з false.  false при порівнянні з числом перетворюється в 0, тому вираз 0 == false дає true. вираз виглядає як true < 1 ** 5
// Спочатку виконується оператор піднесення до степеня: 1 ** 5, що дає 1. Далі вираз стає: true < 1.
// true при порівнянні з числом перетворюється на 1. Тому вираз стає 1 < 1.    Результат: 1 < 1 дає false.





